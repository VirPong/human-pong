\documentclass[12pt, letterpaper]{article}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{cite}

\begin{document}
\title{CS 340 Assignment 2}
\author{Daniel Guilak}
\date{\today}
\maketitle

Iterative software development saw its inception when developers realized that sequential design processes like the waterfall model were laborious and cost ineffective. Thus development through cycles of design, analysis, implementation, deployment, and testing was born. This particular brand of software design has branched off in a myriad of eclectic ways since its introduction into the world of software engineering, but two are particularly interesting in their differences from the original iterative model: extreme programming and the Scrum software development process.

Extreme Programming \cite{beck99} (XP) is a subset of agile software development that takes the aversion that most methods have towards long and drawn-out design stages to a whole new level. Obviously it is not really possible to create software without any sort of design phase (except in introductory computer science classes, of course), so instead XP practices call for a very short design period at the beginning of the project and then throughout the project in a very novel way.
In addition, there are numerous different guidelines that XP calls for, but they can be negotiable within teams as long as everyone agrees upon them. Notable ones include the necessity for pair programming (two programmers at one computer), the presence of an on-site customer at all times, and large open workspaces that are conducive to communication and completing tasks.

The original analysis is done as quickly and efficiently as possible, and broken up into pieces called "stories." Each story is a business-oriented, use-case-esque construction that is testable and easily broken up into small tasks. When a customer decides what stories they want to be included in the next iteration, they essentially are shopping with a budget (of programmers' time and money), they can have a few things, but not all.
Tasks are completed several to a day, iterations are completed several to a week or few weeks, and releases generally happen on a month scale.
Unit tests are written \emph{before} the actual tasks are completed, so that there is a concrete way of determining when a task is finished successfully. All future tasks and releases must also still pass each individual unit test which lends itself towards a stable system.
XP is very test-focused, and the programmers themselves write the tests and test their own code.

The main benefit of XP software development is that a major unknown of the development lifecycle -- the customer's changing requirements -- is heavily mitigated by having the customer always involved.
If a customer decides he or she wants a new feature between iterations, they can choose that particular story for development during the next iteration, but due to their "budget," they might have to take a hit on something else, which (hopefully) reduces the amount of work that the team takes on. But of course, there are a few drawbacks. There is not much room for redundancy in the system, so if one point fails the entire cycle can suffer. Starting without a large design could mean that man-hours could be wasted if a certain trajectory of stories/tasks does not end up being useful in the long run. Also, some programmers might not like pair programming, and might work better by themselves.

	Scrum \cite{rising00} is a similar software development process. First, there is an initial development phase where the marketing group/customer sets a release date, and then they work with developers to determine what features they can achieve by then. A "chief architect" is designated, and he or she is responsible for ensuring that teams (no more than ten members) do not lose sight of the original architecture. All tasks are kept track of in the "backlog," which is consulted before each "sprint" (basically an iteration) which lasts one to four weeks. Each individual team member signs up for tasks which they think they can complete during the duration of the sprint. The team is timeboxed during the sprint, meaning that they can remove functionality to meet the deadline, but they must meet it. At the end of a sprint, the increment is done and all of the teams meet with the stakeholders to determine change in requirements, issues, etc. Daily meetings make sure everyone is on track and allows people to ask for help if they need it.

Both the XP and scrum methods work off of the assumption that small teams are more effective than large teams.
In both models the problem at hand is broken up into smaller pieces, but the scrum model has longer iterations (sprints) and tasks to be completed are assessed before each sprint. In the XP model, each team signs up to complete tasks on a much shorter scale. The scope of the tasks that the scrum team has (in its backlog) is much wider than that of the XP team due to the difference in iteration time, so it could be argued that scrum teams have a better idea of the "big picture" than XP teams. Both methods do not explicitly cite appropriate times for support, but presumably it is taken care of during each iteration and treated as a new task.

Although both software development methods are similar, I believe that the scrum development method would better suit the needs of Vir-Pong at this particular point in time. First of all, it is important to note that the class is comprised of many different programmers at different skill levels. XP is a method that requires some practice and the ability to write very clean and well-documented test cases and code in a very small timebox, which might not be feasible for some. Second, XP does not call for an initial detailed design, which is a concept that (I would argue) is necessary to practice in an introductory software engineering class. Scrum allows for (relatively) much more planning, which is useful for a large project such as this one. Both allow for prioritization of tasks and acheivable goals, and both are helpful when it comes to motivation. 

\bibliography{cs}
\bibliographystyle{plain}
\end{document}
